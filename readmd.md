## 内存池

### 1. concepts

#### 1.1 内存池的意义是什么？

- **内存分配的原理** 一般的内存分配，传统的动态内存分配操作，如`new`操作，每次都需要进行复杂的内存查找、分配等操作。

- **内存池的 trade-off** 一般提到的内存池都是堆空间的内存。操作系统都是一些老妖怪写的代码。如果说自定义的内存池能够优于系统实现，必然不是通过更优写法达到的，而是一些类似于“空间换时间”等等的`trade-off`在。那内存池的实现能够有什么`trade-off`呢？

内存池作为一种重要的内存管理技术，其核心机制是预先分配一块较大的内存区域，并将其划分成多个较小的内存块。这一技术旨在减少频繁的内存分配与释放操作，进而显著提升程序的性能与内存使用效率。内存池的主要意义体现在以下几个方面：

- method: 大体量的的提前分配内存
  - details: 程序化初始化的时候，提前和集中地一次性分配大体量的内存
  - cost: 程序初始化可能略微慢一些，峰值内存需求大；不是按需分配的，因此总内存开销可能大一些。
  - benefit—1: 避免了每次使用的系统调用开销，时进行动态内存分配和释放的开销
  - benefit-2: 因为是有磁性分配的大块内存，内存池分配的连续内存块有助于提升 CPU 缓存的命中率。与系统调用（如`malloc`）获取的内存相比，内存池在初始化时划定了特定的内存范围用于分配和释放，能够保证内存块的连续性。而系统调用`malloc`的内存分配范围是整个内存空间，该空间可能存在多个进程竞争内存资源，导致获取的内存连续性较差。内存池通过维持较高的峰值内存，为 CPU 缓存提供了更有利的条件，使得数据访问时更有可能命中缓存，从而提高程序的运行效率。
- method: 不支持动态大小分配，需要预定义结构
  - details:
  - cost: 固定块大小可能导致对象大小和块大小不匹配，未使用的空间变为内部碎片。
  - benefit-1: 方便提前规划，方便管理，节省空间。
  -
- method: 线程各自的堆空间的分配
  - details: 线程各自私有池
  - benefit-1: 无锁设计，性能有保证
  - cost：手动管理，代码实现麻烦

#### 1.2 内存池的如何实现？

内存池的实现通常包括以下几个步骤：

1. **初始化内存池**：预先分配一大块连续的内存区域。
2. **划分内存块**：将这块内存区域划分为多个固定大小的小块。
3. **管理空闲块**：使用数据结构（如链表或位图）来管理空闲的内存块。
4. **分配内存**：从空闲块中分配内存，更新空闲块的管理结构。
5. **释放内存**：将释放的内存块重新加入空闲块的管理结构中。

#### 1.3 不同大小的内存对象，在内存池中怎么区别对待的？

为了高效管理不同大小的内存对象，内存池通常会使用多级内存池或分层内存池的策略。具体来说：

1. **多级内存池**：为不同大小的内存块创建多个内存池，每个内存池管理一种大小的内存块。例如，可以有一个内存池管理 16 字节的块，另一个内存池管理 32 字节的块，依此类推。
2. **分层内存池**：根据内存块的大小将其分层，每一层管理特定范围大小的内存块。这样可以减少内存碎片，提高内存利用率。

通过这种方式，不同大小的内存对象可以在相应的内存池中进行分配和释放，从而提高内存管理的效率。

在理想情况下，C++ 的 `new` 和内存池的实现都假定最优，内存池的性能提升和两者的权衡主要体现在以下几个方面：

---

### 99. quiz

#### 1. 什么时候需要考虑 new 失败？

- 不支持虚拟内存的时候，才需要考虑 new 失败。
- 数据导入阶段，无法准确预估占内存空间大小，以及限制用户对内存空间的申请。

#### 2. 哪些场景会不支持虚拟内存？

- 嵌入式环境，硬件资源不够，且操作系统有阉割，不一定支持虚拟内存；
- 高实时设备，不能够接受虚拟内存造成的不可预期卡顿，如遥控系统（远程手术机器人、辅助驾驶远程接管）。虚拟内存是被关闭的；

大部分情况下，家用电脑在现代操作系统下，因为有虚拟内存的存在，其实已经不太会出现内存不足的情况了。也就是说除非预期这个操作就是很吃内存的，比如说加载大数据的时候，这个操作可能把内存空间吃满了，虚拟内存也不够，不然不太需要考虑内存不足。

#### 3. 内存池确实不会从根本上解决所有碎片问题

- **外部碎片**：内存池通常通过固定块大小和预分配大块内存的方式避免外部碎片。这种方式确实能保证所有分配单元大小一致，从而不会产生因大小不匹配导致的空闲空间浪费（外部碎片）。
- **内部碎片**：内存池的设计（如固定块大小）可能引入更多的内部碎片，因为实际分配的内存需求可能小于块大小。例如，如果块大小是 64 字节，但分配的对象只需要 50 字节，则会浪费 14 字节。因此，**内存池通常能有效避免外部碎片，但不能完全避免内部碎片**。而内部碎片的严重程度取决于块大小的设计是否适合应用场景。

#### 4. 内存池的核心优化点

内存池的优化点并非直接针对“碎片化”问题，而是侧重于以下几方面：

- **减少系统调用**：内存池在初始化时预分配大块内存，避免了频繁调用系统内存分配器，从而减少系统调用的开销。
- **加快分配速度**：通过简单的数据结构（如链表、栈）管理内存块，分配和释放内存的速度通常远快于操作系统的通用分配器。
- **针对特定场景优化**：通过假设分配对象大小一致或固定生命周期，内存池可以避免碎片整理和复杂的分配算法，提升整体性能。

虽然这些机制可能间接减少碎片化的表现，但并不是直接解决内存碎片的核心目标。

#### 5. 为什么“内存池优化了内存碎片”的说法常见？

这种说法的来源可能基于以下误解：

- 内存池避免了外部碎片，因此被视为“优化了内存碎片”。虽然这是真的，但仅针对外部碎片，而不是全部碎片问题。
- 对比操作系统的通用内存管理，内存池在特定场景下显得更高效，因此很多人将效率的提升归因于碎片优化。
- 在某些应用中，内存池通过精心设计（如多级池管理不同大小的块）能够在一定程度上减少内部碎片，从而被误解为全面解决了碎片问题。

几乎所有内存池资料都会提到能够降低内存碎片化，其实我非常不理解。内存池一般都是按照 8,16,32,64,...等等比数列方式预先申请空间，如果是申请 15 字节的，实际上也是分配 16 字节的空间出去。这当然也有利于字节对齐。我相信操作系统也是实际分配 16 字节空间出去的。那分配的大小也没差啊。内存池不操作大对象内存分配，只操作小对象，感觉内部碎片的说法实在是不够 solid。如果说的是外部碎片，内存池是动态的，也会对外申请空间，会有差吗？现在 os 的内存管理还存在外部碎片问题吗？

#### 6. 内存池的应用场景

高频小对象分配: 游戏开发:游戏中大量小对象(如粒子、子弹、NPC)的动态分配和释放非常频繁，使用内存池可以显著优化性能。

网络编程:网络编程中，大量请求和响应对象(如消息报文)和频创建和销毁非常适合使用内存池。内存管理库:一些容器或数据结构如 std::vector 或 std::deque )在内部可能使用内存池来优化分配性能。

实时系统: 嵌入式设备或实时控制系统中，动态内存分配的延迟可能影响实时性，内存池提供确定性的分配性能。

高性能计算: 在高性能计算程序中，频繁地内存分配和释放会拖累整个程序的性能，内存池可以优化内存管理

服务器开发: 数据库服务器、web 服务器等需要管理大量连接和请求，这些连接涉及大量内存分配，内存池能有效提升服务器性能。
